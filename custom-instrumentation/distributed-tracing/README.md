# Sample distributed tracing application 

This example provides both a BullMQ producer and consumer with a redis instance. 

The producer starts a transaction, adds headers into the transaction and then adds those headers as part of the job data to be added to the queue. The producer and the new relic agent will shutdown after 10 seconds. 

The consumer starts a transaction, processes the jobs from the queue and links the transaction from the producer by accepting its headers that were added as part of the job data. The producer and the new relic agent will shutdown after 60 seconds. 

## Getting started
**Note**: This application requires the use of Node.js v20+ and docker.

 1. Clone or fork this repository.

 2. Setup the redis container

    ```sh
    docker compose up -d 
    ```

 3. Install dependencies and run application

    ```sh
    npm ci
    cp env.sample .env
    # Fill out `NEW_RELIC_LICENSE_KEY` in .env and save 
    # Start the consumer
    npm run start:consumer
    # Start the producer in a different shell
    npm run start:producer
    ```
***You can change the number of messages sent by editing the time in setTimeout in both the producer and the consumer. Increase the time to increase the number of messages sent and processed.*** 

## Exploring Telemetry
After the producer sends a few messages and the consumer processes them, navigate to your application in `APM & Services`.  Select `Distributed Tracing`. A transaction and spans will be created for the messages sent and processed. Since the consumer is running and handling message consumption, Distributed Tracing will link the two entities.

![Producer distributed tracing](./images/producer-dt.png?raw=true "Producer distributed tracing")
![Producer distributed trace](./images/producer-dt-trace.png?raw=true "Producer distributed trace")

The producer service map shows two entities: the producer and consumer. 
![Producer service map](./images/producer-service-map.png?raw=true "Producer service map")

You will see a distributed trace and a service map for the consumer as well. 

![Consumer distributed tracing](./images/consumer-dt.png?raw=true "Consumer distributed tracing")

The consumer service map shows two entities (producer and consumer) and a redis instance. 
![Consumer service map](./images/consumer-service-map.png?raw=true "Consumer service map")

## About `insertDistributedTraceHeaders` and `acceptDistributedTraceHeaders`

For context on how to use `acceptDistributedTraceHeaders` and `insertDistributedTraceHeaders`, first read [Enable distributed tracing with agent APIs](https://docs.newrelic.com/docs/distributed-tracing/enable-configure/language-agents-enable-distributed-tracing/).

You can use `insertDistributedTraceHeaders` and `acceptDistributedTraceHeaders` to link different transactions together. In this example, one background transaction is linked to another background transaction.

`insertDistributedTraceHeaders` modifies the headers map that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with `distributed_tracing.exclude_newrelic_header: true` in the config.

`acceptDistributedTraceHeaders` is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by `insertDistributedTraceHeaders` or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers.
